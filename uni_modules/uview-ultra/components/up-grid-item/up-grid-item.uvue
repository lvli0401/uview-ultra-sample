<template>
	<view
		v-if="parentCol > 0"
	    class="up-grid-item"
	    hover-class="up-grid-item--hover-class"
	    :hover-stay-time="200"
	    @tap="clickHandler"
	    :class="classes"
	    :style="[itemStyle]"
	>
		<slot />
	</view>
</template>

<script>
	import { propsGridItem } from './props';
	import { mpMixin } from '../../libs/mixin/mpMixin';
	import { mixin } from '../../libs/mixin/mixin';
	import { addStyle, deepMerge } from '../../libs/function/index';
	/**
	 * gridItem 提示
	 * @description 宫格组件一般用于同时展示多个同类项目的场景，可以给宫格的项目设置徽标组件(badge)，或者图标等，也可以扩展为左右滑动的轮播形式。搭配up-grid使用
	 * @tutorial https://ijry.github.io/uview-plus/components/grid.html
	 * @property {String | Number}	name		宫格的name ( 默认 null )
	 * @property {String}			bgColor		宫格的背景颜色 （默认 'transparent' ）
	 * @property {Object}			customStyle	自定义样式，对象形式
	 * @event {Function} click 点击宫格触发
	 * @example <up-grid-item></up-grid-item>
	 */
	export default {
		name: "up-grid-item",
		mixins: [mpMixin, mixin, propsGridItem],
		data() {
			return {
				parentData: {
					col: 0, // 父组件划分的宫格数
					border: true, // 是否显示边框，根据父组件决定
					width: 0,
				} as UTSJSONObject,
				width: '' as string,
				classes: [] as String[] // 类名集合，用于判断是否显示右边和下边框
			};
		},
		mounted() {
			this.init()
		},
		emits: ['click'],
		//  微信小程序中 options 选项
		// #ifdef MP-WEIXIN
		options: {
		    virtualHost: true ,//将自定义节点设置成虚拟的，更加接近Vue组件的表现。我们不希望自定义组件的这个节点本身可以设置样式、响应 flex 布局等
		},
		// #endif
		computed: {
			parentCol(): number {
				if (this.parentData != null && this.parentData['col'] != null) {
					return parseInt(this.parentData['col'].toString())
				}
				return 0
			},
			itemStyle() {
				const style = {
					background: this.bgColor
				}
				style['width'] = this.width
				return deepMerge(style, addStyle(this.customStyle))
			}
		},
		methods: {
			init() {
				// 用于在父组件up-grid的children中被添加入子组件时，
				// 重新计算item的边框
				uni.$on('$upGridItem', () => {
					this.gridItemClasses()
				})
				// 父组件的实例
				this.updateParentData()
				// 获取元素该有的长度，nvue下要延时才准确
				this.$nextTick(function(){
					this.getItemWidth()
				})
				// 发出事件，通知所有的grid-item都重新计算自己的边框
				uni.$emit('$upGridItem')
				this.gridItemClasses()
			},
			// 获取父组件的参数
			updateParentData() {
				// 此方法写在mixin中
				// @ts-ignore
				this.getParentData('up-grid');
			},
			clickHandler() {
				let name = this.name
				// 如果没有设置name属性，历遍父组件的children数组，判断当前的元素是否和本实例this相等，找出当前组件的索引
				// @ts-ignore
				const children: ComponentPublicInstance[] = this.parent?.$data['children'] as ComponentPublicInstance[]
				if(children != null && this.name === null) {
					// @ts-ignore
					name = children.findIndex((child: ComponentPublicInstance) => child === this)
				}
				// 调用父组件方法，发出事件
				// @ts-ignore
				this.parent!.$callMethod('childClick', name)
				// this.$parent && this.$parent.childClick(name)
				this.$emit('click', name)
			},
			getItemWidth(): void {
				// 如果是nvue，不能使用百分比，只能使用固定宽度
				let width = ''
				if(this.parent != null) {
					// 获取父组件宽度后，除以栅格数，得出每个item的宽度
					// const parentWidth = await this.getParentWidth()
					// @ts-ignore
					const parentWidth = parseFloat(this.parent.$data['width'].toString())
					// @ts-ignore
					width = (parentWidth / parseInt(this.parentData['col'].toString())).toString() + 'px'
				}
				this.width = width
			},
			// 获取父元素的尺寸
			// getParentWidth() {
			// 	return this.$parent.$callMethod('getWidth2')
			// },
			gridItemClasses() {
				if(this.parentData?.['border'] as Boolean) {
					let classes = [] as String[]
					if (this.parent != null) {
						// @ts-ignore
						(this.parent?.$data['children'] as ComponentPublicInstance[]).map((
							child: ComponentPublicInstance, index: number) =>{
							// let parentCol = parseInt(this.parentData['col'].toString())
							let parentCol = 3
							// @ts-ignore
							if(this === child && parentCol > 0) {
								// @ts-ignore
								const len = (this.parent?.$data?.['children'] as ComponentPublicInstance[]).length
								// 贴近右边屏幕边沿的child，并且最后一个（比如只有横向2个的时候），无需右边框
								if((index + 1) % parentCol !== 0 && index + 1 !== len) {
									classes.push('up-border-right')
								}
								// 总的宫格数量对列数取余的值
								// 如果取余后，值为0，则意味着要将最后一排的宫格，都不需要下边框
								const lessNum = len % parentCol === 0 ? parentCol : len % parentCol
								// 最下面的一排child，无需下边框
								if(index < len - lessNum) {
									classes.push('up-border-bottom')
								}
							} else {
								console.log('parentCol is 0')
							}
						})
					}
					// 支付宝，头条小程序无法动态绑定一个数组类名，否则解析出来的结果会带有","，而导致失效
					// #ifdef MP-ALIPAY || MP-TOUTIAO
					classes = classes.join(' ')
					// #endif
					this.classes = classes
				}
			}
		},
		beforeUnmount() {
			// 移除事件监听，释放性能
			uni.$off('$upGridItem')
		}
	};
</script>

<style lang="scss" scoped>
	@import "../../libs/css/components.scss";
      $up-grid-item-hover-class-opcatiy:.5 !default;
      $up-grid-item-margin-top:1rpx !default;
      $up-grid-item-border-right-width:0.5px !default;
      $up-grid-item-border-bottom-width:0.5px !default;
      $up-grid-item-border-right-color:$up-border-color !default;
      $up-grid-item-border-bottom-color:$up-border-color !default;
	.up-grid-item {
		align-items: center;
		justify-content: center;
		position: relative;
		flex-direction: column;
		/* #ifndef APP-NVUE */
		box-sizing: border-box;
		display: flex;
		/* #endif */

		/* #ifdef MP */
		position: relative;
		float: left;
		/* #endif */

		/* #ifdef MP-WEIXIN */
		margin-top:$up-grid-item-margin-top;
		/* #endif */

		&--hover-class {
			opacity:$up-grid-item-hover-class-opcatiy;
		}
	}
</style>
